<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOS ToDo PWA</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light gray background, typical of iOS */
        }
        /* Custom scrollbar for a cleaner look */
        .task-list-container::-webkit-scrollbar {
            width: 4px;
        }
        .task-list-container::-webkit-scrollbar-thumb {
            background-color: #a0aec0;
            border-radius: 2px;
        }
        /* iOS-style button active state */
        .ios-button:active {
            transform: scale(0.98);
            box-shadow: none !important;
        }
        .ios-button {
            transition: all 0.1s ease-in-out;
        }
    </style>

    <!-- PWA / iOS Home Screen Setup -->
    <!-- These meta tags are crucial for making it installable on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="My ToDo">
    <!-- In a real deployment, you would also link a manifest.json and register a service worker.
         The manifest would describe the app, name, icons, and display mode:
         <link rel="manifest" href="/manifest.json">
         The service worker would handle offline caching:
         navigator.serviceWorker.register('/service-worker.js');
    -->
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <!-- Main App Container - Designed for Mobile Viewport -->
    <div id="app-container" class="w-full max-w-sm bg-white rounded-3xl shadow-xl overflow-hidden flex flex-col min-h-[600px] border border-gray-100">

        <!-- Header/Navigation Bar (iOS Style) -->
        <header class="p-5 border-b border-gray-200 bg-white">
            <h1 class="text-3xl font-bold text-gray-900">Tasks</h1>
            <p class="text-sm text-gray-500 mt-1" id="user-id-display">Signing in...</p>
        </header>

        <!-- Task Input -->
        <div class="p-5 border-b border-gray-100 flex gap-2">
            <input type="text" id="task-input" placeholder="What needs to be done?"
                   class="flex-grow p-3 border border-gray-300 rounded-xl focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none transition duration-150">
            <button id="add-task-btn"
                    class="ios-button bg-blue-600 text-white p-3 rounded-xl font-semibold shadow-md hover:bg-blue-700 disabled:bg-blue-300">
                Add
            </button>
        </div>

        <!-- Task List -->
        <div id="task-list" class="flex-grow overflow-y-auto task-list-container divide-y divide-gray-100">
            <div id="loading-indicator" class="p-5 text-center text-gray-500">Loading tasks...</div>
            <!-- Tasks will be rendered here -->
        </div>

        <!-- Footer/Status Bar -->
        <footer class="p-3 text-center text-sm text-gray-400 border-t border-gray-100">
            Powered by Firebase Firestore
        </footer>

    </div>

    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, addDoc, doc, updateDoc, deleteDoc, query, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId = null;
        let isAuthReady = false;

        setLogLevel('Debug');

        // --- Utility Functions ---
        function getCollectionPath(uid) {
            // Firestore security rule path: /artifacts/{appId}/users/{userId}/{collectionName}
            return `artifacts/${appId}/users/${uid}/tasks`;
        }

        // --- Firebase Initialization and Authentication ---
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        const taskInput = document.getElementById('task-input');
        const addTaskBtn = document.getElementById('add-task-btn');
        const taskList = document.getElementById('task-list');
        const loadingIndicator = document.getElementById('loading-indicator');
        const userIdDisplay = document.getElementById('user-id-display');

        addTaskBtn.disabled = true;

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
            } else {
                // Sign in anonymously if no user is found
                try {
                    if (initialAuthToken) {
                        const result = await signInWithCustomToken(auth, initialAuthToken);
                        userId = result.user.uid;
                    } else {
                        const result = await signInAnonymously(auth);
                        userId = result.user.uid;
                    }
                } catch (error) {
                    console.error("Authentication failed:", error);
                    userId = 'anonymous-error';
                    userIdDisplay.textContent = 'Auth Error. Check console.';
                    return;
                }
            }

            isAuthReady = true;
            addTaskBtn.disabled = false;
            userIdDisplay.textContent = `User ID: ${userId.substring(0, 8)}...`;
            setupRealtimeListener(userId);
        });


        // --- CRUD Operations ---

        const addTask = async (text) => {
            if (!isAuthReady || !userId) return console.error("Auth not ready.");
            if (!text.trim()) return;

            const tasksCol = collection(db, getCollectionPath(userId));
            try {
                await addDoc(tasksCol, {
                    text: text.trim(),
                    completed: false,
                    createdAt: Date.now()
                });
                taskInput.value = ''; // Clear input on success
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        };

        const toggleTask = async (taskId, completed) => {
            if (!isAuthReady || !userId) return;
            const taskRef = doc(db, getCollectionPath(userId), taskId);
            try {
                await updateDoc(taskRef, {
                    completed: !completed
                });
            } catch (e) {
                console.error("Error toggling task: ", e);
            }
        };

        const deleteTask = async (taskId) => {
            if (!isAuthReady || !userId) return;
            const taskRef = doc(db, getCollectionPath(userId), taskId);
            try {
                await deleteDoc(taskRef);
            } catch (e) {
                console.error("Error deleting task: ", e);
            }
        };

        // --- Realtime Data Listener ---
        function setupRealtimeListener(uid) {
            if (!isAuthReady || !uid) return;

            const tasksColRef = collection(db, getCollectionPath(uid));
            // Note: We use in-memory sorting later to avoid needing an index for orderBy in Firestore
            const q = query(tasksColRef);

            onSnapshot(q, (snapshot) => {
                let tasks = [];
                snapshot.forEach((doc) => {
                    tasks.push({ id: doc.id, ...doc.data() });
                });
                
                // 1. Sort by completed status (incomplete first)
                // 2. Then sort by createdAt (newest first)
                tasks.sort((a, b) => {
                    if (a.completed !== b.completed) {
                        return a.completed ? 1 : -1; // Incomplete (false) comes first
                    }
                    return b.createdAt - a.createdAt; // Newest first
                });

                renderTasks(tasks);
            }, (error) => {
                console.error("Snapshot listener error:", error);
                loadingIndicator.textContent = "Error loading data.";
            });
        }

        // --- UI Rendering ---
        function renderTasks(tasks) {
            taskList.innerHTML = ''; // Clear existing tasks

            if (tasks.length === 0) {
                taskList.innerHTML = `
                    <div class="p-5 text-center text-gray-500">
                        <svg class="w-8 h-8 mx-auto mb-2 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M10 12h.01"></path></svg>
                        <p class="font-medium">No tasks yet!</p>
                        <p class="text-xs">Add one above to get started.</p>
                    </div>
                `;
                return;
            }

            tasks.forEach(task => {
                const li = document.createElement('div');
                li.className = `p-4 flex items-center transition duration-200 ${task.completed ? 'bg-green-50' : 'hover:bg-gray-50'}`;
                li.setAttribute('data-id', task.id);

                // Checkbox/Toggle Button
                const toggle = document.createElement('button');
                toggle.className = `flex-shrink-0 w-6 h-6 rounded-full border-2 mr-4 transition duration-150 flex items-center justify-center ${task.completed ? 'bg-green-500 border-green-500' : 'border-gray-300'}`;
                toggle.innerHTML = task.completed ? '<svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path></svg>' : '';
                toggle.onclick = () => toggleTask(task.id, task.completed);

                // Task Text
                const text = document.createElement('span');
                text.className = `flex-grow text-gray-800 break-words ${task.completed ? 'line-through text-gray-400' : ''}`;
                text.textContent = task.text;

                // Delete Button (Small red 'X')
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'ios-button ml-4 p-1 rounded-full text-red-500 hover:text-red-700 opacity-0 group-hover:opacity-100 transition duration-150';
                deleteBtn.innerHTML = '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';
                deleteBtn.onclick = () => deleteTask(task.id);

                li.appendChild(toggle);
                li.appendChild(text);
                li.appendChild(deleteBtn);
                taskList.appendChild(li);
            });
        }

        // --- Event Listeners ---
        addTaskBtn.addEventListener('click', () => {
            addTask(taskInput.value);
        });

        taskInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addTask(taskInput.value);
            }
        });

    </script>
</body>
</html>